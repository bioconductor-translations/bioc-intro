---
source: Rmd
title: Introduction à R
teaching: 60
exercises: 60
---

```{r, include=FALSE}
```

::::::::::::::::::::::::::::::::::::::: objectives

- Définissez les termes suivants relatifs à R : objet, affectation, appel, fonction, arguments, options.
- Attribuez des valeurs aux objets dans R.
- Apprenez à _nommer_ des objets
- Utilisez les commentaires pour informer le script.
- Résoudre des opérations arithmétiques simples dans R.
- Appelez des fonctions et utilisez des arguments pour modifier leurs options par défaut.
- Inspectez le contenu des vecteurs et manipulez leur contenu.
- Sous-ensembler et extraire des valeurs à partir de vecteurs.
- Analysez les vecteurs avec des données manquantes.

::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- Premières commandes dans R

::::::::::::::::::::::::::::::::::::::::::::::::

> Cet épisode est basé sur la leçon _Analyse des données et
> Visualisation dans R pour les écologistes_ de Data Carpentries.

## Créer des objets dans R

Vous pouvez obtenir le résultat de R simplement en tapant math dans la console :

```{r, purl=TRUE}
3 + 5
12 / 7
```

Cependant, pour faire des choses utiles et intéressantes, nous devons attribuer des _valeurs_ à
_objets_. Pour créer un objet, nous devons lui donner un nom suivi de l'opérateur d'affectation
`<-`, et de la valeur que nous voulons lui donner :

```{r, purl=TRUE}
poids_kg <- 55
```

`<-` est l'opérateur d'affectation. Il attribue des valeurs à droite aux objets
à gauche. Ainsi, après avoir exécuté `x <- 3`, la valeur de `x` est
`3`. La flèche peut être lue comme 3 **entre dans** `x`.  Pour des raisons historiques
, vous pouvez également utiliser `=` pour les affectations, mais pas dans tous les contextes
. En raison du
[légères différences](https://blog.revolutionanalytics.com/2008/12/use-equals-or-arrow-for-assignment.html)
dans la syntaxe, il est une bonne pratique de toujours utiliser `<-` pour les affectations.

In RStudio, typing <kbd>Alt</kbd> + <kbd>\-</kbd> (push <kbd>Alt</kbd>
at the same time as the <kbd>\-</kbd> key) will write `<-` in a single
keystroke in a PC, while typing <kbd>Option</kbd> + <kbd>\-</kbd> (push <kbd>Option</kbd> at the same time as the <kbd>\-</kbd> key) does the
same in a Mac.

### Nommer les variables

Les objets peuvent recevoir n'importe quel nom tel que « x », « current_temperature » ou
« subject_id ». Vous voulez que les noms de vos objets soient explicites et pas trop
longs. Ils ne peuvent pas commencer par un nombre (`2x` n'est pas valide, mais `x2`
l'est). R est sensible à la casse (par exemple, `weight_kg` est différent de
`Weight_kg`). Certains noms ne peuvent pas être utilisés car ils
sont les noms de fonctions fondamentales dans R (par exemple, `if`, `else`,
`for`, voir
[ ici](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Reserved.html)
pour une liste complète). En général, même si c'est autorisé, il est préférable de
de ne pas utiliser d'autres noms de fonctions (par exemple, `c`, `T`, `mean`, `data`, `df`,
` poids`). En cas de doute, consultez l'aide pour voir si le nom est déjà
utilisé. Il est également préférable d'éviter les points (`.`) dans un nom d'objet comme dans
`my.dataset`. There are many functions in R with dots in their names
for historical reasons, but because dots have a special meaning in R
(for methods) and other programming languages, it's best to avoid
them. Il est également recommandé d'utiliser des noms pour les noms d'objets et des verbes
pour les noms de fonctions. Il est important d'être cohérent dans le style de
votre code (où vous placez les espaces, comment vous nommez les objets, etc.). L'utilisation d'un style de codage
cohérent rend votre code plus clair à lire pour votre
futur moi et vos collaborateurs. Dans R, certains guides de style populaires
sont [de Google](https://google.github.io/styleguide/Rguide.xml), le
[tidyverse](https://style. Tidyverse.org/) et le Bioconductor
style
guide. Le
Tidyverse est très complet et peut sembler écrasant au début
. Vous pouvez installer le package
[**`lintr`**](https://github.com/jimhester/lintr) pour
vérifier automatiquement les problèmes dans le style de votre code.

> **Objets et variables** : ce que l'on appelle des « objets » dans « R » sont
> connus sous le nom de « variables » dans de nombreux autres langages de programmation. Selon
> le contexte, « objet » et « variable » peuvent avoir des significations radicalement
> différentes. Cependant, dans cette leçon, les deux mots sont utilisés
> de manière synonyme. Pour plus d'informations
> [voir ici.](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Objects)

Lors de l'attribution d'une valeur à un objet, R n'imprime rien. Vous
pouvez forcer R à imprimer la valeur en utilisant des parenthèses ou en tapant le
nom de l'objet :

```{r, purl=TRUE}
weight_kg <- 55 # n'imprime rien
(weight_kg <- 55) # mais mettre des parenthèses autour de l'appel imprime la valeur de `weight_kg`
weight_kg # et taper également le nom du objet
```

Maintenant que R a « weight_kg » en mémoire, nous pouvons faire de l'arithmétique avec. Pour
exemple, nous pouvons vouloir convertir ce poids en livres (le poids en livres est 2,2 fois le poids en kg) :

```{r, purl=TRUE}
2,2 * poids_kg
```

On peut également changer la valeur d'un objet en lui attribuant une nouvelle :

```{r, purl=TRUE}
poids_kg <- 57,5
2,2 * poids_kg
```

Cela signifie que l'attribution d'une valeur à un objet ne modifie pas les valeurs de
autres objets. Par exemple, stockons le poids de l'animal en livres dans un nouvel objet
, `weight_lb` :

```{r, purl=TRUE}
poids_lb <- 2,2 * poids_kg
```

puis remplacez « weight_kg » par 100.

```{r}
poids_kg <- 100
```

::::::::::::::::::::::::::::::::::::::: défi

## Défi:

Selon vous, quel est le contenu actuel de l'objet `weight_lb` ?
126\.5 ou 220 ?

::::::::::::::::::::::::::::::::::::::::::::::::

## commentaires

Le caractère de commentaire dans R est `#`, tout ce qui se trouve à droite d'un `#` dans un script
sera ignoré par R. Il est utile de laisser des notes et
des explications dans vos scripts .

RStudio permet de commenter ou décommenter facilement un paragraphe : après
sélectionnant les lignes que vous souhaitez commenter, appuyez en même temps sur
votre clavier <kbd>Ctrl</kbd> + <kbd>Maj</kbd> + <kbd>C</kbd>. If
you only want to comment out one line, you can put the cursor at any
location of that line (i.e. no need to select the whole line), then
press <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd>.

::::::::::::::::::::::::::::::::::::::: défi

## Défi

Quelles sont les valeurs après chaque instruction suivante ?

```{r, purl=TRUE}
masse <- 47,5 # masse ?
âge <- 122 # âge ?
masse <- masse * 2.0 # masse ?
âge <- âge - 20 # âge ?
mass_index <- masse/âge # mass_index ?
```

::::::::::::::::::::::::::::::::::::::::::::::::

## Fonctions et leurs arguments

Les fonctions sont des "scripts prédéfinis" qui automatisent des ensembles de commandes plus complexes
, y compris les affectations d'opérations, etc. De nombreuses fonctions sont prédéfinies ou peuvent être
rendues disponibles en important des _packages_ R (nous en parlerons plus tard). Une fonction
obtient généralement une ou plusieurs entrées appelées _arguments_. Les fonctions renvoient souvent (mais pas
toujours) une _valeur_. Un exemple typique serait la fonction `sqrt()`. L'entrée
(l'argument) doit être un nombre et la valeur de retour (en fait, la sortie
) est la racine carrée de ce nombre. Exécuter une fonction (« l'exécuter »)
est appelé _appeler_ la fonction. Un exemple d'appel de fonction est :

```{r, eval=FALSE, purl=FALSE}
b <- sqrt(a)
```

Ici, la valeur de `a` est donnée à la fonction `sqrt()`, la fonction `sqrt()`
calcule la racine carrée, et renvoie la valeur qui est ensuite attribuée à
l'objet 'b'. Cette fonction est très simple car elle ne prend qu’un seul argument.

The return 'value' of a function need not be numerical (like that of `sqrt()`),
and it also does not need to be a single item: it can be a set of things, or
even a dataset. Nous le verrons lorsque nous lirons des fichiers de données dans R.

Les arguments peuvent être n'importe quoi, non seulement des nombres ou des noms de fichiers, mais aussi d'autres objets
. La signification exacte de chaque argument diffère selon la fonction et doit être
recherchée dans la documentation (voir ci-dessous). Certaines fonctions prennent des arguments qui
peuvent soit être spécifiés par l'utilisateur, soit, s'ils sont laissés de côté, prendre une valeur _par défaut_ :
ceux-ci sont appelés _options_. Les options sont généralement utilisées pour modifier le fonctionnement de la fonction
, par exemple si elle ignore les « mauvaises valeurs » ou quel symbole
utiliser dans un tracé.  Cependant, si vous souhaitez quelque chose de spécifique, vous pouvez spécifier une valeur
de votre choix qui sera utilisée à la place de la valeur par défaut.

Essayons une fonction qui peut prendre plusieurs arguments : `round()`.

```{r, results="show", purl=TRUE}
rond(3.14159)
```

Ici, nous avons appelé `round()` avec un seul argument, `3.14159`, et il a
renvoyé la valeur `3`.  En effet, la valeur par défaut est d'arrondir au nombre entier
le plus proche. Si nous voulons plus de chiffres, nous pouvons voir comment procéder en obtenant
des informations sur la fonction `round`.  Nous pouvons utiliser `args(round)` ou consulter l'aide
pour cette fonction en utilisant `?round`.

```{r, results="show", purl=TRUE}
arguments (rond)
```

```{r, eval=FALSE, purl=TRUE}
?rond
```

Nous voyons que si nous voulons un nombre différent de chiffres, nous pouvons
taper `digits=2` ou autant que nous le voulons.

```{r, results="show", purl=TRUE}
rond(3.14159, chiffres = 2)
```

Si vous fournissez les arguments exactement dans le même ordre que celui dans lequel ils sont définis, vous
n'avez pas besoin de les nommer :

```{r, results="show", purl=TRUE}
rond(3.14159, 2)
```

Et si vous nommez les arguments, vous pouvez changer leur ordre :

```{r, results="show", purl=TRUE}
rond(chiffres = 2, x = 3,14159)
```

Il est recommandé de placer les arguments non facultatifs (comme le nombre que vous arrondissez
) en premier dans votre appel de fonction et de spécifier les noms de tous les arguments
facultatifs.  Si vous ne le faites pas, quelqu'un qui lit votre code devra peut-être rechercher la définition
d'une fonction avec des arguments inconnus pour comprendre ce que vous faites
. En spécifiant le nom des arguments, vous protégez également
contre d'éventuelles modifications futures dans l'interface de la fonction, qui peuvent
potentiellement ajouter de nouveaux arguments entre ceux existants.

## Vecteurs et types de données

Un vecteur est le type de données le plus courant et le plus basique dans R, et est à peu près
le cheval de bataille de R. Un vecteur est composé d'une série de valeurs, telles que
nombres ou caractères. Nous pouvons attribuer une série de valeurs à un vecteur en utilisant
la fonction `c()`. Par exemple, nous pouvons créer un vecteur de poids d'animaux et l'attribuer
à un nouvel objet `weight_g` :

```{r, purl=TRUE}
poids_g <- c(50, 60, 65, 82)
poids_g
```

Un vecteur peut également contenir des caractères :

```{r, purl=TRUE}
molécules <- c("adna", "rna", "protein")
molécules
```

Les guillemets autour de « adn », « arn », etc. sont ici essentiels. Sans les guillemets
, R supposera qu'il existe des objets appelés « adn », « arn » et
« protéine ». Comme ces objets n'existent pas dans la mémoire de R, il y aura
un message d'erreur.

Il existe de nombreuses fonctions qui vous permettent d'inspecter le contenu d'un vecteur
. `length()` vous indique combien d'éléments se trouvent dans un vecteur particulier :

```{r, purl=TRUE}
longueur (poids_g)
longueur (molécules)
```

Une caractéristique importante d'un vecteur est que tous les éléments sont du
même type de données.  La fonction `class()` indique la classe (le type d'élément
) d'un objet :

```{r, purl=TRUE}
classe (poids_g)
classe (molécules)
```

La fonction `str()` fournit un aperçu de la structure d'un objet
et de ses éléments. C'est une fonction utile lorsque vous travaillez avec
des objets volumineux et complexes :

```{r, purl=TRUE}
str(poids_g)
str(molécules)
```

Vous pouvez utiliser la fonction `c()` pour ajouter d'autres éléments à votre vecteur :

```{r}
poids_g <- c(poids_g, 90) # ajouter à la fin du vecteur
poids_g <- c(30, poids_g) # ajouter au début du vecteur
poids_g
```

Dans la première ligne, nous prenons le vecteur d'origine `weight_g`, ajoutons la valeur
`90` à la fin de celui-ci et enregistrons le résultat dans
`weight_g`. Ensuite, nous ajoutons la valeur « 30 » au début, en enregistrant à nouveau
le résultat dans « weight_g ».

Nous pouvons faire cela encore et encore pour développer un vecteur ou assembler un ensemble de données
.  Au fur et à mesure que nous programmons, cela peut être utile pour ajouter les résultats que nous
collectons ou calculons.

Un **vecteur atomique** est le **type de données** R le plus simple et est un vecteur linéaire
d'un seul type. Ci-dessus, nous avons vu 2 des 6 principaux types de vecteurs \*\*atomiques
\*\* que R utilise : `"caractère"` et `"numérique"` (ou
`"double"`). Ce sont les éléments de base à partir desquels tous les objets R
sont construits. Les 4 autres types de **vecteurs atomiques** sont :

- `"logique"` pour `TRUE` et `FALSE` (le type de données booléen)
- `"integer"` pour les nombres entiers (par exemple, `2L`, le `L` indique à R
  que c'est un entier)
- `"complexe"` pour représenter des nombres complexes avec des parties réelles et imaginaires
  (par exemple, `1 + 4i`) et c'est tout ce que nous allons dire à leur sujet
- `"raw"` pour les bitstreams dont nous ne parlerons pas davantage

Vous pouvez vérifier le type de votre vecteur en utilisant la fonction `typeof()`
et en saisissant votre vecteur comme argument.

Les vecteurs sont l'une des nombreuses **structures de données** utilisées par R. Les autres
importants sont les listes (`list`), les matrices (`matrix`), les trames de données
(`data.frame`), les facteurs (`factor`) et les tableaux (`array` ).

::::::::::::::::::::::::::::::::::::::: défi

## Défi:

Nous avons vu que les vecteurs atomiques peuvent être de type caractère, numérique (ou
double), entier et logique. Mais que se passe-t-il si nous essayons de mélanger
ces types dans un seul vecteur ?

::::::::::::::: solution

## Solution

R les convertit implicitement pour qu'ils soient tous du même type

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::: défi

## Défi:

Que se passera-t-il dans chacun de ces exemples ? (indice : utilisez `class()` pour
vérifier le type de données de vos objets et tapez leurs noms pour voir ce qui se passe) :

```{r, eval=TRUE}
num_char <- c(1, 2, 3, "a")
num_logical <- c(1, 2, 3, TRUE, FALSE)
char_logical <- c("a", " b", "c", VRAI)
délicat <- c(1, 2, 3, "4")
```

::::::::::::::: solution

## Solution

```{r, purl=TRUE}
class(num_char)
num_char
class(num_logical)
num_logical
class(char_logical)
char_logical
class(tricky)
tricky
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::: défi

## Défi:

Pourquoi pensez-vous que cela arrive ?

::::::::::::::: solution

## Solution

Les vecteurs ne peuvent appartenir qu’à un seul type de données. R essaie de convertir (contraindre)
le contenu de ce vecteur pour trouver un _dénominateur commun_ qui
ne perd aucune information.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::: défi

## Défi:

Combien de valeurs dans `combined_logical` sont `"TRUE"` (sous forme de caractère)
dans l'exemple suivant :

```{r, eval=TRUE}
num_logical <- c(1, 2, 3, TRUE)
char_logical <- c("a", "b", "c", TRUE)
combiné_logique <- c(num_logical, char_logical )
```

::::::::::::::: solution

## Solution

Seulement un. Il n'y a pas de mémoire des types de données passés et la coercition
se produit la première fois que le vecteur est évalué. Par conséquent, le `TRUE`
dans `num_logical` est converti en `1` avant d'être converti
en `"1"` dans `combined_logical`.

```{r}
combiné_logique
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::: défi

## Défi:

Dans R, nous appelons la conversion d'objets d'une classe vers une autre classe
_coercition_. Ces conversions se produisent selon une hiérarchie,
selon laquelle certains types sont préférentiellement contraints vers d'autres types. Pouvez-vous
dessiner un diagramme qui représente la hiérarchie de la façon dont ces types de données
sont forcés ?

::::::::::::::: solution

## Solution

logique → numérique → caractère ← logique

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

```{r, echo=FALSE, eval=FALSE, purl=TRUE}
## Nous avons vu que les vecteurs atomiques peuvent être de type caractère, numérique, entier et
## logique. Mais que se passe-t-il si nous essayons de mélanger ces types dans un seul vecteur
## ?

## Que va-t-il se passer dans chacun de ces exemples ? (indice : utilisez `class()` pour
## vérifier le type de données de votre objet)
num_char <- c(1, 2, 3, "a")

num_logical <- c(1, 2, 3, TRUE)

char_logical <- c("a", "b", "c", TRUE)

délicat <- c(1, 2 , 3, "4")

## Pourquoi pensez-vous que cela arrive ?

## Vous avez probablement remarqué que des objets de types différents sont
## convertis en un seul type partagé au sein d'un vecteur. Dans R, nous appelons
## convertir des objets d'une classe en une autre classe
## _coercion_. Ces conversions se produisent selon une hiérarchie,
## selon laquelle certains types sont préférentiellement contraints vers d'autres types. Pouvez-vous
## dessiner un diagramme qui représente la hiérarchie de la façon dont ces types de données
## sont forcés ?
```

## Vecteurs de sous-ensemble

Si l'on veut extraire une ou plusieurs valeurs d'un vecteur, il faut
fournir un ou plusieurs indices entre crochets. Par exemple:

```{r, results="show", purl=TRUE}
molécules <- c("ADN", "arn", "peptide", "protéine")
molécules[2]
molécules[c(3, 2)]
```

On peut également répéter les indices pour créer un objet avec plus d'éléments
que celui d'origine :

```{r, results="show", purl=TRUE}
more_molecules <- molécules[c(1, 2, 3, 2, 1, 4)]
more_molecules
```

Les indices R commencent à 1. Les langages de programmation comme Fortran, MATLAB,
Julia et R commencent à compter à 1, car c'est ce que font généralement les êtres humains
. Les langages de la famille C (y compris C++, Java, Perl,
et Python) comptent à partir de 0 car c'est plus simple à faire pour les ordinateurs.

Enfin, il est également possible d'obtenir tous les éléments d'un vecteur
sauf certains éléments spécifiés en utilisant des indices négatifs :

```{r}
molécules ## toutes les molécules
molécules[-1] ## toutes sauf la première
molécules[-c(1, 3)] ## toutes sauf les 1ère/3ème
molécules[c(-1, -3)] ## toutes sauf les 1ère/3ème
```

## Sous-ensemble conditionnel

Une autre méthode courante de sous-ensemble consiste à utiliser un vecteur logique. `TRUE`
sélectionnera l'élément avec le même index, tandis que `FALSE` ne le fera pas :

```{r, purl=TRUE}
poids_g <- c(21, 34, 39, 54, 55)
poids_g[c(VRAI, FAUX, VRAI, VRAI, FAUX)]
```

Généralement, ces vecteurs logiques ne sont pas tapés à la main, mais sont la sortie
d'autres fonctions ou tests logiques. Par exemple, si vous
souhaitez sélectionner uniquement les valeurs supérieures à 50 :

```{r, purl=TRUE}
## will return logicals with TRUE for the indices that meet
## the condition
weight_g > 50
## so we can use this to select only the values above 50
weight_g[weight_g > 50]
```

Vous pouvez combiner plusieurs tests en utilisant `&` (les deux conditions sont vraies,
AND) ou `|` (au moins une des conditions est vraie, OR) :

```{r, results="show", purl=TRUE}
poids_g[poids_g < 30 | poids_g > 50]
poids_g[poids_g >= 30 & poids_g == 21]
```

Ici, `<` signifie "inférieur à", `>` pour "supérieur à", `>=` pour
"supérieur ou égal à" et `==` pour "égal à". The double equal
sign `==` is a test for numerical equality between the left and right
hand sides, and should not be confused with the single `=` sign, which
performs variable assignment (similar to `<-`).

Une tâche courante consiste à rechercher certaines chaînes dans un vecteur.  On pourrait
utiliser l'opérateur "ou" `|` pour tester l'égalité de plusieurs valeurs, mais
cela peut rapidement devenir fastidieux. La fonction `%in%` permet de
tester si l'un des éléments d'un vecteur de recherche est trouvé :

```{r, purl=TRUE}
molecules <- c("dna", "rna", "protein", "peptide")
molecules[molecules == "rna" | molecules == "dna"] # returns both rna and dna
molecules %in% c("rna", "dna", "metabolite", "peptide", "glycerol")
molecules[molecules %in% c("rna", "dna", "metabolite", "peptide", "glycerol")]
```

::::::::::::::::::::::::::::::::::::::: défi

## Défi:

Pouvez-vous comprendre pourquoi « quatre » > « cinq » renvoie « VRAI » ?

::::::::::::::: solution

## Solution

```{r}
"quatre" > "cinq"
```

Lorsque vous utilisez `>` ou `<` sur des chaînes, R compare leur ordre alphabétique.
Ici, `"quatre"` vient après `"cinq"`, et est donc _supérieur à_
.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

## Des noms

Il est possible de nommer chaque élément d'un vecteur. Le morceau de code ci-dessous
montre un vecteur initial sans aucun nom, comment les noms sont définis et
récupérés.

```{r}
x <- c(1, 5, 3, 5, 10)
noms(x) ## pas de noms
noms(x) <- c("A", "B", " C", "D", "E")
noms(x) ## maintenant nous avons des noms
```

Lorsqu'un vecteur possède des noms, il est possible d'accéder aux éléments par leur nom
, en plus de leur index.

```{r}
x[c(1, 3)]
x[c("A", "C")]
```

## Données manquantes

Comme R a été conçu pour analyser des ensembles de données, il inclut le concept de
données manquantes (ce qui est rare dans d'autres langages de programmation
). Les données manquantes sont représentées dans les vecteurs par « NA ».

Lorsque vous effectuez des opérations sur des nombres, la plupart des fonctions renverront « NA » si
les données avec lesquelles vous travaillez incluent des valeurs manquantes. Cette fonctionnalité
rend plus difficile l'ignorance des cas où vous avez affaire à
données manquantes.  Vous pouvez ajouter l'argument `na.rm = TRUE` pour calculer
le résultat en ignorant les valeurs manquantes.

```{r}
heights <- c(2, 4, 4, NA, 6)
mean(heights)
max(heights)
mean(heights, na.rm = TRUE)
max(heights, na.rm = TRUE)
```

Si vos données incluent des valeurs manquantes, vous souhaiterez peut-être vous familiariser
avec les fonctions `is.na()`, `na.omit()` et `complete.cases()`. Voir
ci-dessous pour des exemples.

```{r}
## Extrayez les éléments pour lesquels il ne manque pas de valeurs.
heights[!is.na(heights)]

## Renvoie l'objet avec les cas incomplets supprimés.
## L'objet retourné est un vecteur atomique de type `"numeric"`
## (ou `"double"`).
na.omit(heights)

## Extrayez les éléments qui sont des cas complets.
## L'objet retourné est un vecteur atomique de type `"numeric"`
## (ou `"double"`).
hauteurs[complete.cases(heights)]
```

::::::::::::::::::::::::::::::::::::::: défi

## Défi:

1. En utilisant ce vecteur de hauteurs en pouces, créez un nouveau vecteur en supprimant les NA.

```{r}
hauteurs <- c(63, 69, 60, 65, NA, 68, 61, 70, 61, 59, 64, 69, 63, 63, NA, 72, 65, 64, 70, 63, 65)
```

2. Utilisez la fonction `median()` pour calculer la médiane du vecteur `heights`.
3. Utilisez R pour déterminer combien de personnes dans l’ensemble mesurent plus de 67 pouces.

::::::::::::::: solution

## Solution

```{r, purl=TRUE}
heights_no_na <- heights[!is.na(heights)]
## ou
heights_no_na <- na.omit(heights)
```

```{r, purl=TRUE}
médiane (hauteurs, na.rm = TRUE)
```

```{r, purl=TRUE}
hauteurs_above_67 <- heights_no_na[heights_no_na > 67]
longueur(heights_above_67)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

## Génération de vecteurs {#sec:genvec}

```{r, echo=FALSE}
set.seed(1)
```

### Constructeurs

Il existe quelques fonctions pour générer des vecteurs de différents types. Pour
générer un vecteur de valeurs numériques, on peut utiliser le constructeur `numeric()`
, fournissant la longueur du vecteur de sortie comme paramètre
. Les valeurs seront initialisées à 0.

```{r, purl=TRUE}
numérique(3)
numérique(10)
```

Notez que si l'on demande un vecteur de numériques de longueur 0, on obtient
exactement cela :

```{r, purl=TRUE}
numérique(0)
```

Il existe des constructeurs similaires pour les caractères et les logiques, nommés respectivement
`character()` et `logical()`.

::::::::::::::::::::::::::::::::::::::: défi

## Défi:

Quelles sont les valeurs par défaut pour les caractères et les vecteurs logiques ?

::::::::::::::: solution

## Solution

```{r, purl=TRUE}
caractère(2) ## le caractère vide
logique(2) ## FALSE
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

### Répliquer des éléments

La fonction `rep` permet de répéter une valeur un certain nombre de
fois. Si nous voulons initier un vecteur de numériques de longueur 5 avec
la valeur -1, par exemple, nous pourrions faire ce qui suit :

```{r, purl=TRUE}
représentant(-1, 5)
```

De même, pour générer un vecteur rempli de valeurs manquantes, ce qui
est souvent une bonne façon de commencer, sans poser d'hypothèses sur les données
à collecter :

```{r, purl=TRUE}
représentant(NA, 5)
```

`rep` peut prendre en entrée des vecteurs de n'importe quelle longueur (ci-dessus, nous avons utilisé des vecteurs
de longueur 1) et de n'importe quel type. Par exemple, si nous voulons répéter cinq fois les valeurs
1, 2 et 3, nous procéderions comme suit :

```{r, purl=TRUE}
représentant(c(1, 2, 3), 5)
```

::::::::::::::::::::::::::::::::::::::: défi

## Défi:

Et si nous voulions répéter les valeurs 1, 2 et 3 cinq fois, mais que
obtenait cinq 1, cinq 2 et cinq 3 dans cet ordre ? Il existe deux
possibilités - voir `?rep` ou `?sort` pour obtenir de l'aide.

::::::::::::::: solution

## Solution

```{r, purl=TRUE}
rep(c(1, 2, 3), chacun = 5)
sort(rep(c(1, 2, 3), 5))
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

### Génération de séquence

Une autre fonction très utile est `seq`, pour générer une séquence de
nombres. Par exemple, pour générer une séquence d'entiers de 1 à 20
par pas de 2, on utiliserait :

```{r, purl=TRUE}
séq(de = 1, à = 20, par = 2)
```

La valeur par défaut de `by` est 1 et, étant donné que la génération d'une séquence
d'une valeur à une autre avec des pas de 1 est fréquemment utilisée,
il existe un raccourci :

```{r, purl=TRUE}
seq(1, 5, 1)
seq(1, 5) ## par défaut par
1:5
```

Pour générer une séquence de nombres de 1 à 20 de longueur finale de 3,
on utiliserait :

```{r, purl=TRUE}
seq (de = 1, à = 20, longueur.out = 3)
```

### Échantillons aléatoires et permutations

Un dernier groupe de fonctions utiles sont celles qui génèrent des données aléatoires
. Le premier, `sample`, génère une permutation aléatoire de
un autre vecteur. Par exemple, pour tirer au sort un ordre aléatoire de 10 étudiants
à l'examen oral, j'attribue d'abord à chaque étudiant un numéro de 1 à dix (par exemple
en fonction de l'ordre alphabétique de son nom) puis :

```{r, purl=TRUE}
échantillon (1:10)
```

Sans autres arguments, `sample` renverra une permutation de tous les
éléments du vecteur. Si je veux un échantillon aléatoire d'une certaine taille, je
définirais cette valeur comme deuxième argument. Ci-dessous, j'échantillonne 5
lettres aléatoires de l'alphabet contenu dans le vecteur `letters` prédéfini :

```{r, purl=TRUE}
échantillon(lettres, 5)
```

Si je voulais une sortie plus grande que le vecteur d'entrée, ou pouvoir
dessiner certains éléments plusieurs fois, je devrais définir l'argument `replace`
sur `TRUE` :

```{r, purl=TRUE}
échantillon (1:5, 10, remplacer = VRAI)
```

::::::::::::::::::::::::::::::::::::::: défi

## Défi:

En essayant les fonctions ci-dessus, vous aurez réalisé que les échantillons
sont effectivement aléatoires et qu'on n'obtient pas deux fois la même permutation
. Pour pouvoir reproduire ces tirages aléatoires, on peut
définir manuellement la graine de génération de nombres aléatoires avec `set.seed()`
avant de tirer l'échantillon aléatoire.

Testez cette fonctionnalité avec votre voisin. Dessinez d'abord deux permutations aléatoires
de « 1:10 » indépendamment et observez que vous obtenez
résultats différents.

Définissez maintenant la graine avec, par exemple, `set.seed(123)` et répétez le tirage au sort
. Observez que vous obtenez désormais les mêmes tirages au sort.

Répétez en définissant une graine différente.

::::::::::::::: solution

## Solution

Différentes permutations

```{r, purl=TRUE}
échantillon (1:10)
échantillon (1:10)
```

Mêmes permutations avec la graine 123

```{r, purl=TRUE}
set.seed(123)
échantillon(1:10)
set.seed(123)
échantillon(1:10)
```

Une graine différente

```{r, purl=TRUE}
set.seed(1)
échantillon(1:10)
set.seed(1)
échantillon(1:10)
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::

### Extraire des échantillons à partir d'une distribution normale

La dernière fonction que nous allons voir est `rnorm`, qui tire un échantillon aléatoire
à partir d'une distribution normale. Deux distributions normales de moyennes 0
et 100 et d'écarts types 1 et 5, notées _N(0, 1)_ et
_N(100, 5)_, sont présentées ci-dessous.

```{r, echo=FALSE, fig.width=12, fig.height=6, fig.cap="Two normal distributions: *N(0, 1)* on the left and *N(100, 5)* on the right."}
par(mfrow = c(1, 2))
plot(density(rnorm(1000)), main = "", sub = "N(0, 1)")
plot(densité (rnorm(1000, 100, 5)), principal = "", sous = "N(100, 5)")
```

Les trois arguments, `n`, `mean` et `sd`, définissent la taille de l'échantillon
, et les paramètres de la distribution normale, c'est-à-dire la moyenne
et son écart type. Les valeurs par défaut de ce dernier sont 0 et 1.

```{r, purl=TRUE}
rnorme(5)
rnorme(5, 2, 2)
rnorme(5, 100, 5)
```

Maintenant que nous avons appris à écrire des scripts et les bases des structures de données
de R, nous sommes prêts à commencer à travailler avec des données plus volumineuses et à
en apprendre davantage sur les trames de données.

:::::::::::::::::::::::::::::::::::::::: points clés

- Comment interagir avec R

::::::::::::::::::::::::::::::::::::::::::::::::
